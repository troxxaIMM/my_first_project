# Ответы на вопросы по Git и веб-разработке

## Git

### 1. Какие три основные области работы с файлами в Git и чем они отличаются?

**Рабочая папка (Working Directory)** - текущее состояние файлов в проекте, где вы непосредственно работаете с кодом.

**Индекс (Staging Area)** - промежуточная область для файлов перед коммитом, где формируется "снимок" изменений.

**Репозиторий (Repository)** - база данных Git, хранящая всю историю проекта, коммиты и метаданные.

### 2. Что происходит при выполнении команд:

**git add** - добавляет изменения из рабочей папки в индекс.

**git commit** - создает новый коммит из проиндексированных изменений в локальный репозиторий.

**git push** - отправляет коммиты из локального репозитория в удаленный репозиторий.

### 3. Почему важно писать информативные сообщения к коммитам?

Информативные сообщения помогают понять историю изменений, облегчают поиск конкретных правок, помогают новым разработчикам разобраться в проекте и упрощают отладку.

### 4. Чем отличается `git add имя_файла` от `git add .`?

**`git add имя_файла`** - добавляет в индекс только указанный файл.

**`git add .`** - добавляет все измененные и новые файлы в текущей директории и поддиректориях.

### 5. Что показывает команда `git status` и как меняется ее вывод?

`git status` показывает измененные, но не добавленные в индекс файлы, файлы в индексе, готовые к коммиту, и неотслеживаемые файлы.

### 6. Для чего нужна команда `git remote add origin URL` и что означает "origin"?

Команда связывает локальный репозиторий с удаленным репозиторием. "origin" - стандартное имя для удаленного репозитория-источника.

### 7. Зачем нужен флаг `-u` в команде `git push -u origin main`?

Флаг `-u` устанавливает связь между локальной веткой и удаленной веткой, позволяя в дальнейшем использовать просто `git push`.

### 8. Что такое ветка по умолчанию и какая у вас создалась?

**Ветка по умолчанию** - основная ветка проекта. У меня создалась ветка **main** - основная ветка разработки, считающаяся стабильной версией проекта.

### 9. Как просмотреть историю коммитов и какую информацию вы видите?

**Команда:** `git log` показывает хеш коммита, автора, дату и время коммита, сообщение коммита.

### 10. Что произойдет, если сделать изменения в файле, но не выполнить `git add` перед `git commit`?

Изменения не попадут в коммит. Git создаст коммит только из файлов, добавленных в индекс с помощью `git add`.

## Семантическая верстка

### 1. Чем семантическая верстка отличается от несемантической и почему она важна?

**Семантическая верстка** использует HTML-теги, несущие смысловое значение. **Несемантическая** использует в основном `<div>` и `<span>` без конкретного смысла.

Важность: улучшает доступность для скринридеров, повышает SEO-оптимизацию, упрощает чтение и поддержку кода.

### 2. В каких случаях следует использовать `<article>` вместо `<section>`?

**`<article>`** используется для независимого, самодостаточного контента: пост в блоге, новостная статья, комментарий пользователя.

**`<section>`** используется для группировки тематического контента внутри документа: глава книги, введение на странице.

### 3. Для чего предназначены теги `<header>` и `<footer>` и могут ли они использоваться несколько раз?

**`<header>`** - для вводного контента или навигации. **`<footer>`** - для заключительного контента. Да, они могут использоваться несколько раз.

### 4. Какой тег следует использовать для основного контента страницы и почему не стоит использовать `<div>`?

Для основного контента используется **`<main>`**. `<div>` не дает семантического значения, ухудшает навигацию для скринридеров и SEO.

### 5. В чем разница между `<nav>` и обычным списком ссылок?

**`<nav>`** - семантический тег для основной навигации, который указывает на важный навигационный блок и улучшает доступность.

### 6. Для чего используется атрибут datetime в теге `<time>` и почему он важен?

**`datetime`** предоставляет машиночитаемую версию времени, что позволяет поисковым системам понимать даты и упрощает их обработку.

### 7. Какие преимущества дает использование `<figure>` и `<figcaption>`?

Преимущества: семантическая связь между изображением и подписью, улучшенная доступность, лучшее понимание контекста поисковыми системами.

### 8. Когда следует использовать `<aside>` и какой контент в него помещать?

**`<aside>`** используется для контента, косвенно связанного с основным содержанием: боковые панели, дополнительная информация, рекламные баннеры.

### 9. Как семантическая разметка влияет на SEO и доступность веб-страницы?

Для SEO: поисковые системы лучше понимают структуру контента. Для доступности: скринридеры могут правильно ориентировать пользователей.

### 10. Какие теги вы использовали для улучшения структуры документа?

Я использовал: `<header>`, `<nav>`, `<main>`, `<article>`, `<section>`, `<aside>`, `<footer>`, `<figure>` и `<figcaption>`.

## CSS

### 1. Разница между селектором по классу и по ID

- **Специфичность**: ID имеет специфичность (1,0,0), класс - (0,1,0)
- **Повторное использование**: Классы можно применять к множеству элементов, ID должен быть уникальным

### 2. Как работает каскад в CSS

Порядок применения стилей при конфликте: важность (!important), специфичность селектора, порядок в коде.

### 3. Расчет специфичности

- `ul li.important` = (0,1,2)
- `#site-title` = (1,0,0)
- `.content > .featured-post` = (0,2,0)

### 4. Наследуемые и ненаследуемые свойства

**Наследуемые**: `color`, `font-family`, `line-height`
**Ненаследуемые**: `margin`, `padding`, `border`

### 5. Разница между > и пробелом

- `A > B` - выбирает непосредственных потомков
- `A B` - выбирает всех потомков любого уровня вложенности

### 6. Псевдоклассы :hover и :nth-child()

- `:hover` - стили при наведении
- `:nth-child()` - выбор элементов по порядку

### 7. Правило !important

Переопределяет все другие правила. Используется осторожно, так как усложняет поддержку кода.

### 8. Псевдоэлементы ::before и ::after

Добавляют декоративный контент: иконки, цитаты, оформление.

### 9. Порядок применения при одинаковой специфичности

Браузер применяет последнее объявление в коде.

### 10. Инструменты разработчика

Показывают примененные стили, специфичность, наследование, позволяют экспериментировать с изменениями в реальном времени.

## Flexbox

### 1. Основное свойство CSS для Flexbox

Основное свойство - `display: flex`. После его применения дочерние элементы становятся flex-элементами.

### 2. Разница между justify-content и align-items

- `justify-content` - выравнивание вдоль основной оси
- `align-items` - выравнивание вдоль поперечной оси

### 3. Свойство flex-direction

Определяет направление основной оси: `row`, `row-reverse`, `column`, `column-reverse`.

### 4. Сокращенная запись flex: 1

Эквивалентно: `flex-grow: 1`, `flex-shrink: 1`, `flex-basis: 0`.

### 5. Свойство flex-wrap

Определяет, могут ли элементы переноситься на новую строку.

### 6. Разница между align-content и align-items

- `align-items` - выравнивание отдельных элементов в строке
- `align-content` - выравнивание строк в многорядном flex-контейнере

### 7. Свойство order

Определяет порядок отображения элементов без изменения HTML.

### 8. Осевые линии в Flexbox

- Основная ось (main axis) - определяется flex-direction
- Поперечная ось (cross axis) - перпендикулярна основной

### 9. Адаптивность без медиа-запросов

Использование `flex-wrap: wrap` и `flex-basis` с min/max-width.

### 10. Преимущества использования gap вместо margins

**Преимущества использования gap:**
- Простота и удобство - одно свойство вместо множества margin-правил
- Автоматическое устранение промежутков по краям контейнера
- Единообразие промежутков между всеми элементами

```markdown
# Ответы на вопросы для самоконтроля

## 1. Какое основное свойство включает CSS Grid и чем принципиально отличается от Flexbox?

**Основное свойство:** `display: grid`

**Отличия от Flexbox:**
- CSS Grid - двумерная система (работает со строками и столбцами одновременно)
- Flexbox - одномерная система (работает либо со строками, либо со столбцами)
- Grid позволяет создавать сложные макеты с точным позиционированием элементов в двух направлениях
- Flexbox лучше подходит для выравнивания и распределения элементов в одном направлении
- Grid идеален для создания макетов всего сайта, Flexbox - для компонентов внутри макета

## 2. В чем разница между grid-template-columns и grid-auto-columns? Когда следует использовать каждое?

**grid-template-columns:** Определяет явные колонки сетки с заданными размерами. Используется когда известно точное количество колонок.

**grid-auto-columns:** Определяет размер неявных колонок (тех, которые создаются автоматически при размещении элементов вне явной сетки).

**Примеры использования:**
```css
/* Явное определение 3 колонок */
.container {
  grid-template-columns: 100px 1fr 200px;
}

/* Автоматические колонки для динамического контента */
.container {
  grid-auto-columns: minmax(150px, 1fr);
}
```

## 3. Что делают функции repeat(), minmax() и auto-fit в определении grid-шаблона? Приведите примеры.

**repeat():** Повторяет шаблон определенное количество раз
```css
grid-template-columns: repeat(4, 1fr); /* 4 колонки по 1fr */
grid-template-columns: repeat(2, 100px 200px); /* повторяет паттерн 100px 200px дважды */
```

**minmax():** Задает минимальный и максимальный размер для трека
```css
grid-template-columns: minmax(200px, 1fr); /* мин. 200px, макс. 1fr */
grid-template-rows: minmax(100px, auto); /* мин. 100px, макс. по контенту */
```

**auto-fit:** Автоматически подбирает количество колонок чтобы заполнить доступное пространство, растягивая существующие колонки
```css
grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
```

## 4. Как работают именованные grid-области и какие преимущества они дают при создании макетов?

**Принцип работы:** Создаются именованные области с помощью `grid-template-areas`, а элементы размещаются с помощью `grid-area`

**Пример:**
```css
.container {
  grid-template-areas:
    "header header"
    "sidebar content"
    "footer footer";
}

.header { grid-area: header; }
.sidebar { grid-area: sidebar; }
.content { grid-area: content; }
.footer { grid-area: footer; }
```

**Преимущества:**
- Наглядность структуры макета
- Легкое перераспределение элементов
- Простота изменения макета через медиа-запросы
- Упрощение поддержки кода
- Интуитивно понятное именование областей

## 5. Объясните систему нумерации grid-линий и как с помощью grid-column и grid-row размещать элементы.

**Система нумерации:** 
- Линии нумеруются от 1 (начиная с внешнего края контейнера)
- Также доступны отрицательные индексы с конца (-1, -2, и т.д.)
- Между каждой парой линий находится grid-трек

**grid-column/grid-row:** Определяют положение элемента между линиями
```css
.element {
  grid-column: 1 / 3;    /* от линии 1 до линии 3 (занимает 2 колонки) */
  grid-row: 2 / 4;       /* от линии 2 до линии 4 (занимает 2 строки) */
}

/* Сокращенная запись */
.element {
  grid-column: 2;        /* начинается с линии 2, заканчивается на следующей */
  grid-row: 1 / span 2;  /* начинается с линии 1, занимает 2 строки */
}
```

## 6. Что такое grid-gap (или gap) и чем он лучше margins для создания промежутков в сетке?

**gap:** Свойство для создания промежутков между grid-элементами (ранее `grid-gap`)

**Преимущества перед margins:**
- Равномерные отступы между всеми элементами автоматически
- Не влияет на расчет размеров элементов
- Простота использования и поддержки (один параметр вместо множества margin)
- Работает только между элементами, не создает внешних отступов
- Легко изменять отступы для всей сетки одним свойством

**Пример:**
```css
.container {
  gap: 20px; /* одинаковые отступы по горизонтали и вертикали */
  gap: 10px 20px; /* row-gap column-gap */
}
```

## 7. Как свойства justify-items и align-items влияют на выравнивание grid-элементов?

**justify-items:** Выравнивание элементов по горизонтальной оси (внутри grid-ячейки)

**align-items:** Выравнивание элементов по вертикальной оси (внутри grid-ячейки)

**Общие значения:**
- `start` - выравнивание к началу ячейки
- `end` - выравнивание к концу ячейки
- `center` - выравнивание по центру ячейки
- `stretch` - растягивание на всю ячейку (по умолчанию)

**Пример:**
```css
.container {
  justify-items: center;   /* горизонтально по центру */
  align-items: start;      /* вертикально в начале */
}
```

## 8. В чем разница между auto-fill и auto-fit при создании адаптивных сеток?

**auto-fill:** Создает столько колонок сколько помещается в контейнер, даже если они пустые
**auto-fit:** Растягивает существующие колонки чтобы заполнить все доступное пространство

**Разница видна когда:**
- Элементов меньше чем может поместиться колонок
- При `auto-fill` остаются пустые колонки
- При `auto-fit` существующие колонки растягиваются

**Пример:**
```css
/* С auto-fill могут оставаться пустые колонки */
grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));

/* С auto-fit колонки всегда заполняют все пространство */
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
```

## 9. Как создать сложные макеты с помощью grid-template-areas и какие правила именования областей существуют?

**Создание макета:**
```css
.grid-container {
  display: grid;
  grid-template-areas:
    "header header header"
    "sidebar content ads"
    "sidebar footer footer";
  grid-template-columns: 200px 1fr 150px;
  grid-template-rows: auto 1fr auto;
}
```

**Размещение элементов:**
```css
.header { grid-area: header; }
.sidebar { grid-area: sidebar; }
.content { grid-area: content; }
.ads { grid-area: ads; }
.footer { grid-area: footer; }
```

**Правила именования:**
- Имена должны быть в кавычках
- Каждая строка в отдельных кавычках
- Точка (.) для пустых ячеек
- Одинаковые имена создают объединенные области
- Имена должны быть валидными CSS идентификаторами

## 10. Какие преимущества дает CSS Grid перед другими методами верстки для создания сложных двумерных макетов?

**Преимущества:**
- Простота создания сложных двумерных макетов
- Полный контроль над расположением элементов по строкам и столбцам
- Меньше HTML-разметки (не нужны дополнительные обертки)
- Легкая адаптивность через медиа-запросы
- Гибкость в изменении структуры без изменения HTML
- Современный стандарт с хорошей поддержкой браузеров
- Интеграция с другими CSS-технологиями (Flexbox, positioning)
- Мощные функции для автоматического размещения (auto-placement)
- Простое создание отступов между элементами (gap)
- Возможность перекрытия элементов без абсолютного позиционирования
```
